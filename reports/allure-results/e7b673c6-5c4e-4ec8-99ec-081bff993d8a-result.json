{"name": "test_export_offer", "status": "broken", "statusDetails": {"message": "ValueError: Can only compare identically-labeled (both index and columns) DataFrame objects", "trace": "driver_with_downloads = <selenium.webdriver.chrome.webdriver.WebDriver (session=\"645540d89d3493e3e665c900e7965bbc\")>\n\n    def test_export_offer(driver_with_downloads):\n        driver = driver_with_downloads\n        lp = LoginPage(driver)\n        o = Offer(driver)\n        lp.do_login(Constant.USERNAME, Constant.PASSWORD)\n        db = DashBoard(driver)\n        db.element_displayed(db.DASHBOARD_TEXT)\n        db.click_offer_ele()\n        assert isinstance(o.is_table_data_present(), str), \"Table data not present\"\n        o.js_click(o.OFFER_EXPORT_BTN)\n        time.sleep(5)\n        files = [f for f in os.listdir(driver.download_dir) if f.endswith(\".csv\")]\n        assert files, \"No CSV file found!\"\n        csv_file_path = os.path.join(driver.download_dir, files[0])\n        csv_data = pd.read_csv(csv_file_path, sep=\",\", engine=\"python\")\n        # get UI dataframe\n        ui_df = o.get_all_pages_as_dataframe()\n        # save UI data for debugging/reference\n        ui_df.to_csv(\"ui_all_data_export.csv\", index=False)\n        ui_csv = pd.read_csv(\"ui_all_data_export.csv\")\n        # Strip column names\n        csv_data.columns = [col.strip() for col in csv_data.columns]\n        ui_csv.columns = [col.strip() for col in ui_csv.columns]\n        # csv_data = csv_data[ui_df.columns]\n        csv_data = csv_data.astype(str)\n        ui_csv = ui_csv.astype(str)\n        csv_data = csv_data.applymap(normalize_value)\n        ui_csv = ui_csv.applymap(normalize_value)\n        #Show differences\n>       diff = csv_data.compare(ui_csv, keep_shape=True, keep_equal=False)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntests\\test_offer.py:220: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.venv\\Lib\\site-packages\\pandas\\core\\frame.py:8600: in compare\n    return super().compare(\n.venv\\Lib\\site-packages\\pandas\\core\\generic.py:10140: in compare\n    mask = ~((self == other) | (self.isna() & other.isna()))\n              ^^^^^^^^^^^^^\n.venv\\Lib\\site-packages\\pandas\\core\\ops\\common.py:76: in new_method\n    return method(self, other)\n           ^^^^^^^^^^^^^^^^^^^\n.venv\\Lib\\site-packages\\pandas\\core\\arraylike.py:40: in __eq__\n    return self._cmp_method(other, operator.eq)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n.venv\\Lib\\site-packages\\pandas\\core\\frame.py:7904: in _cmp_method\n    self, other = self._align_for_op(other, axis, flex=False, level=None)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself =    Offer Id                  Offer Name  ...    Status Request Received\n0        55       DuplicateAvinashOffer  ...  ... Active                0\n15       19                 ABC-Testing  ...    Active                0\n\n[16 rows x 7 columns]\nother =    Offer ID                  Offer Name  ...    Status Request Received\n0        55       DuplicateAvinashOffer  ...  ... Active                0\n15       19                 ABC-Testing  ...    Active                0\n\n[16 rows x 7 columns]\naxis = 1, flex = False, level = None\n\n    def _align_for_op(\n        self,\n        other,\n        axis: AxisInt,\n        flex: bool | None = False,\n        level: Level | None = None,\n    ):\n        \"\"\"\n        Convert rhs to meet lhs dims if input is list, tuple or np.ndarray.\n    \n        Parameters\n        ----------\n        left : DataFrame\n        right : Any\n        axis : int\n        flex : bool or None, default False\n            Whether this is a flex op, in which case we reindex.\n            None indicates not to check for alignment.\n        level : int or level name, default None\n    \n        Returns\n        -------\n        left : DataFrame\n        right : Any\n        \"\"\"\n        left, right = self, other\n    \n        def to_series(right):\n            msg = (\n                \"Unable to coerce to Series, \"\n                \"length must be {req_len}: given {given_len}\"\n            )\n    \n            # pass dtype to avoid doing inference, which would break consistency\n            #  with Index/Series ops\n            dtype = None\n            if getattr(right, \"dtype\", None) == object:\n                # can't pass right.dtype unconditionally as that would break on e.g.\n                #  datetime64[h] ndarray\n                dtype = object\n    \n            if axis == 0:\n                if len(left.index) != len(right):\n                    raise ValueError(\n                        msg.format(req_len=len(left.index), given_len=len(right))\n                    )\n                right = left._constructor_sliced(right, index=left.index, dtype=dtype)\n            else:\n                if len(left.columns) != len(right):\n                    raise ValueError(\n                        msg.format(req_len=len(left.columns), given_len=len(right))\n                    )\n                right = left._constructor_sliced(right, index=left.columns, dtype=dtype)\n            return right\n    \n        if isinstance(right, np.ndarray):\n            if right.ndim == 1:\n                right = to_series(right)\n    \n            elif right.ndim == 2:\n                # We need to pass dtype=right.dtype to retain object dtype\n                #  otherwise we lose consistency with Index and array ops\n                dtype = None\n                if right.dtype == object:\n                    # can't pass right.dtype unconditionally as that would break on e.g.\n                    #  datetime64[h] ndarray\n                    dtype = object\n    \n                if right.shape == left.shape:\n                    right = left._constructor(\n                        right, index=left.index, columns=left.columns, dtype=dtype\n                    )\n    \n                elif right.shape[0] == left.shape[0] and right.shape[1] == 1:\n                    # Broadcast across columns\n                    right = np.broadcast_to(right, left.shape)\n                    right = left._constructor(\n                        right, index=left.index, columns=left.columns, dtype=dtype\n                    )\n    \n                elif right.shape[1] == left.shape[1] and right.shape[0] == 1:\n                    # Broadcast along rows\n                    right = to_series(right[0, :])\n    \n                else:\n                    raise ValueError(\n                        \"Unable to coerce to DataFrame, shape \"\n                        f\"must be {left.shape}: given {right.shape}\"\n                    )\n    \n            elif right.ndim > 2:\n                raise ValueError(\n                    \"Unable to coerce to Series/DataFrame, \"\n                    f\"dimension must be <= 2: {right.shape}\"\n                )\n    \n        elif is_list_like(right) and not isinstance(right, (Series, DataFrame)):\n            # GH#36702. Raise when attempting arithmetic with list of array-like.\n            if any(is_array_like(el) for el in right):\n                raise ValueError(\n                    f\"Unable to coerce list of {type(right[0])} to Series/DataFrame\"\n                )\n            # GH#17901\n            right = to_series(right)\n    \n        if flex is not None and isinstance(right, DataFrame):\n            if not left._indexed_same(right):\n                if flex:\n                    left, right = left.align(\n                        right, join=\"outer\", level=level, copy=False\n                    )\n                else:\n>                   raise ValueError(\n                        \"Can only compare identically-labeled (both index and columns) \"\n                        \"DataFrame objects\"\nE                       ValueError: Can only compare identically-labeled (both index and columns) DataFrame objects\n\n.venv\\Lib\\site-packages\\pandas\\core\\frame.py:8203: ValueError"}, "start": 1759133206509, "stop": 1759133230349, "uuid": "24530174-2cd0-4afa-8206-327259956d13", "historyId": "4708d067d01fce0834722e65bb61c4bd", "testCaseId": "4708d067d01fce0834722e65bb61c4bd", "fullName": "tests.test_offer#test_export_offer", "labels": [{"name": "parentSuite", "value": "tests"}, {"name": "suite", "value": "test_offer"}, {"name": "host", "value": "DESKTOP-THM7RLI"}, {"name": "thread", "value": "4920-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "tests.test_offer"}], "titlePath": ["tests", "test_offer.py"]}